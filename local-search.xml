<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python 2处理MySQL latin表里的中文数据</title>
    <link href="/2020/08/19/Python%202%E5%A4%84%E7%90%86MySQL%20latin%E8%A1%A8%E9%87%8C%E7%9A%84%E4%B8%AD%E6%96%87%E6%95%B0%E6%8D%AE/"/>
    <url>/2020/08/19/Python%202%E5%A4%84%E7%90%86MySQL%20latin%E8%A1%A8%E9%87%8C%E7%9A%84%E4%B8%AD%E6%96%87%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><p><a href="http://cenalulu.github.io/mysql/mysql-mojibake/">被MySQL Server接收到以后实际上已经发生了编码不一致的情况。但是由于Latin1字符集对于自己表述范围外的字符不会做任何处理，而是保留原值。这样的行为也使得错进错出成为了可能。</a></p></blockquote><p>​    我们先提个小问题：在MySQL下，latin编码的表可以存储中文数据吗？</p><p>​    答案是可以的。</p><p>​    MySQL下，latin表会对自己表述范围外的字符不会做任何处理，<strong>所以latin表中存储其他编码的数据是可以实现的</strong>。</p><p>​    我个人还是非常不建议读者们这样实现的。在latin表可以存储中文数据，就是一件非常Dirty的工作，是一个大坑，我就是被这样坑过来的，在各种<code>encode</code>、<code>decode</code>中迷失了自我。为了帮助其他人免受我之前的折磨，我才决定写下本篇文章。</p><p>​    那么在latin表里存储中文数据会有什么问题呢？ </p><ul><li>程序软件处理中文数据时，需要中文数据进行各种编码解码；</li><li>因为latin表的兼容性，同一张latin表里，<strong>可能同时存在了多种编码的数据</strong>，开发人员在写处理的程序软件需要考虑到这一部分兼容性；</li><li>用户使用show create table命令的时候，无法确认表中的中文数据的实际编码，而且终端的编码与数据编码不一致，在查询中文数据的时候会出现乱码，需要用户不断的测试来找到正确的编码</li></ul><h2 id="2-处理建议"><a href="#2-处理建议" class="headerlink" title="2. 处理建议"></a>2. 处理建议</h2><p>​    常见的在latin表中存储中文的数据一般为GBK编码和UTF-8编码，如果你不可避免的需要处理latin表里的中文数据，那么我这里可以提供两种处理方式（Python 2的方式）。</p><h3 id="2-1-转换成对应编码的str"><a href="#2-1-转换成对应编码的str" class="headerlink" title="2.1 转换成对应编码的str"></a>2.1 转换成对应编码的str</h3><ul><li><p>处理要点：</p><ul><li>在处理latin表的Python脚本开头指定了中文数据的对应编码（<code># -*- coding: utf-8 -*-</code>或者<code># -*- coding: gbk -*-</code>）;</li><li>Python脚本在与DB建立连接时，需要指定连接的<code>charset</code>为<code>latin1</code>;</li><li>往DB写入中文数据时，<strong>脚本里的中文数据字符串此时的编码即为脚本开头指定的编码</strong>；</li><li>读取中文数据时，从DB获取了中文数据后，需要将中文数据**由<code>unicode</code>类型以<code>latin</code>编码的方式<code>encode</code>**，还原成对应编码的<code>str</code> (这个时候可以根据自己的需要进行<code>print</code>、或者写入到文件里等等各种操作，读者可自由发挥)</li></ul></li><li><p>缺点：</p><ul><li>用户需要事先明确latin表里的中文数据编码；</li><li>latin表中需要处理的中文字段的编码需要是一致；</li></ul><p>处理的Python脚本示例如下：</p></li></ul><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment"># -*- coding: utf-8 -*-     #在Python文件的开头指定编码，值为GBK或者utf-8</span><span class="hljs-keyword">import</span> MySQLdb<span class="hljs-comment"># 作者为了方便，对原有的MySQLdb数据库类的一些db操作进行的一个简单的封装成DataBase这个类，大家也可以直接使用MySQLdb</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataBase</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, user=<span class="hljs-string">&quot;root&quot;</span>, passwd=<span class="hljs-string">&quot;123456&quot;</span>, db=<span class="hljs-string">&quot;test&quot;</span>, charset=<span class="hljs-string">&quot;latin1&quot;</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> passwd:            self.db = MySQLdb.connect(host=host, user=user,                                      db=db, charset=charset)        <span class="hljs-keyword">else</span>:            self.db = MySQLdb.connect(host=host, user=user, passwd=passwd,                                      db=db, charset=charset)        self.cursor = self.db.cursor()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, sql</span>):</span>        <span class="hljs-keyword">try</span>:            self.cursor.execute(sql)            self.db.commit()            results = self.cursor.fetchall()            <span class="hljs-keyword">return</span> results        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(str(e))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">executemany</span>(<span class="hljs-params">self, sql, param_list</span>):</span>        <span class="hljs-keyword">try</span>:            self.cursor.executemany(sql, param_list)            self.db.commit()        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(str(e))db = DataBase()<span class="hljs-comment"># 1. 写入数据</span>student_name = <span class="hljs-string">&#x27;小刚&#x27;</span>    <span class="hljs-comment"># 该中文数据此时为utf-8的字符串</span>sql = <span class="hljs-string">&quot;insert into test1 values (1, &#x27;%s&#x27;, &#x27;male&#x27;)&quot;</span> %(student_name)db.execute(sql)<span class="hljs-comment"># 2. 获取数据</span>sql = <span class="hljs-string">&quot;select name from test1&quot;</span>results = db.execute(sql)<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:    print(type(result[<span class="hljs-number">0</span>]))    print([result[<span class="hljs-number">0</span>]]) <span class="hljs-comment"># 查看这里打印出来的数据，你就会发现这里的不是正常的unicode数据，如果你直接print的话，在显示的时候编码转换就会发生异常</span>    print(result[<span class="hljs-number">0</span>].encode(<span class="hljs-string">&#x27;latin1&#x27;</span>)) <span class="hljs-comment"># 此时中文数据为utf-8编码，与脚本编码一致，可以正常打印</span></code></pre><h3 id="2-2-转换成unicode"><a href="#2-2-转换成unicode" class="headerlink" title="2.2 转换成unicode"></a>2.2 转换成unicode</h3><ul><li><p>处理要点：</p><ul><li>在处理latin表的Python脚本开头指定了中文数据的对应编码（<code># -*- coding: utf-8 -*-</code>或者<code># -*- coding: gbk -*-</code>，根据你的习惯来设置）;</li><li>与DB建立连接时，需要指定连接的<code>charset</code>为<code>latin1</code>;</li><li>写入中文数据时，脚本中涉及到的中文数据我们均让它成为<code>unicode</code>类型，如<code>u&#39;小红&#39;</code></li><li>读取中文数据时，从DB获取了中文数据后，将中文数据由<code>unicode</code>以<code>latin</code>编码的方式<code>encode</code>，还原成对应编码的<code>str</code> ，最后再<code>decode</code>成<code>unicode</code>类型（我喜欢转换成<code>unicode</code>类型，python脚本在使用print函数打印<code>unicode</code>类型的内容，<code>unicode</code>会自动转换成合适的编码）</li></ul><p>处理的Python脚本示例如下：</p></li></ul><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment"># -*- coding: utf-8 -*-     #在Python文件的开头指定编码，值为GBK或者utf-8</span><span class="hljs-keyword">import</span> MySQLdb<span class="hljs-comment"># 作者为了方便，对原有的MySQLdb数据库类的一些db操作进行的一个简单的封装成DataBase这个类，大家也可以直接使用MySQLdb</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataBase</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, user=<span class="hljs-string">&quot;root&quot;</span>, passwd=<span class="hljs-string">&quot;123456&quot;</span>, db=<span class="hljs-string">&quot;test&quot;</span>, charset=<span class="hljs-string">&quot;latin1&quot;</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> passwd:            self.db = MySQLdb.connect(host=host, user=user,                                      db=db, charset=charset)        <span class="hljs-keyword">else</span>:            self.db = MySQLdb.connect(host=host, user=user, passwd=passwd,                                      db=db, charset=charset)        self.cursor = self.db.cursor()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, sql</span>):</span>        <span class="hljs-keyword">try</span>:            self.cursor.execute(sql)            self.db.commit()            results = self.cursor.fetchall()            <span class="hljs-keyword">return</span> results        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(str(e))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">executemany</span>(<span class="hljs-params">self, sql, param_list</span>):</span>        <span class="hljs-keyword">try</span>:            self.cursor.executemany(sql, param_list)            self.db.commit()        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(str(e))db = DataBase()<span class="hljs-comment"># 1. 写入数据</span>student_name = <span class="hljs-string">u&#x27;小红&#x27;</span>    <span class="hljs-comment"># 该中文数据此时为unicode类型</span>sql = <span class="hljs-string">&quot;insert into test1 values (2, &#x27;%s&#x27;, &#x27;female&#x27;)&quot;</span> %(student_name.encode(<span class="hljs-string">&#x27;gbk&#x27;</span>)) <span class="hljs-comment"># 我们将unicode数据根据自己需要，转换成对应编码，比如这里我转换成gbk编码</span>db.execute(sql)<span class="hljs-comment"># 2. 获取数据</span>sql = <span class="hljs-string">&quot;select name from test1&quot;</span>results = db.execute(sql)<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:    print(type(result[<span class="hljs-number">0</span>]))    print([result[<span class="hljs-number">0</span>]]) <span class="hljs-comment"># 查看这里打印出来的数据，你就会发现这里的不是正常的unicode数据，如果你直接print的话，在显示的时候编码转换就会发生异常</span>    print(result[<span class="hljs-number">0</span>].encode(<span class="hljs-string">&#x27;latin1&#x27;</span>).decode(<span class="hljs-string">&#x27;gbk&#x27;</span>)) <span class="hljs-comment"># 此时中文数据为unicode，转换成unicode则不会因为中文数据编码和脚本编码不一致而导致打印出现异常</span></code></pre><h2 id="3-测试小实验"><a href="#3-测试小实验" class="headerlink" title="3. 测试小实验"></a>3. 测试小实验</h2><p>​    实践可以让我们加深如何使用Python 2处理MySQL latin表里的中文数据。如果你手上的latin表是线上环境，我相信你也是不敢随意测试。下面就让我们手把手的把测试环境给搭建起来，好好地实践一番。</p><h3 id="3-1-运行MySQL"><a href="#3-1-运行MySQL" class="headerlink" title="3.1 运行MySQL"></a>3.1 运行MySQL</h3><p>​    在你的Linux虚拟机上，我们通过docker快速拉起一个MySQL实例：</p><pre><code class="hljs angelscript">$ docker run -itd --name mysql-test -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> mysql:<span class="hljs-number">5.7</span></code></pre><p>​    这里我简单解释一下这条命令的意思：我们以<code>mysql:5.7</code>这个镜像为模板，新启动一个命名为<code>mysql-test</code>的容器，容器的<code>3306</code>端口与母机的<code>3306</code>端口关联，同时我们设置了<code>mysql-test</code>容器里的root账号密码为123456</p><blockquote><p>注：docker的安装和一些常用的docker命令这里就不展开篇幅了，网络上还是有不少不错的资源的，努力搜索一下。</p></blockquote><h3 id="3-2-建立测试用的DB和表"><a href="#3-2-建立测试用的DB和表" class="headerlink" title="3.2 建立测试用的DB和表"></a>3.2 建立测试用的DB和表</h3><pre><code class="hljs SQL"><span class="hljs-comment"># 通过命令行的方式连接至MySQL上</span>$ mysql -h 127.0.0.1 -u root -p&#x27;123456&#x27; <span class="hljs-comment">--default-character-set=latin1</span><span class="hljs-comment"># 在MySQL的命令行终端下，执行以下三条SQL</span><span class="hljs-comment"># 创建数据库</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> <span class="hljs-keyword">test</span>;<span class="hljs-keyword">use</span> <span class="hljs-keyword">test</span>;<span class="hljs-comment"># 创建测试用的test1表，表中包含了三个字段，我们后续将会在name字段中插入中文数据</span><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test1 (    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,    <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    sex <span class="hljs-built_in">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=latin1</code></pre><p>​        操作过程如下所示：</p><pre><code class="hljs SQL">$ mysql -h 127.0.0.1 -u root -p&#x27;123456&#x27; <span class="hljs-comment">--default-character-set=latin1    #连接至我们新启动的DB上</span>Welcome to the MariaDB monitor.  Commands <span class="hljs-keyword">end</span> <span class="hljs-keyword">with</span> ; or \g.Your MySQL connection id is 37Server version: 5.7.26 MySQL Community Server (GPL)Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type &#x27;<span class="hljs-keyword">help</span>;&#x27; or &#x27;\h&#x27; for help. Type &#x27;\c&#x27; to clear the current input statement.MySQL [(none)]&gt; create database test;     # 建立测试用的test库；MySQL [(none)]&gt; use test;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup <span class="hljs-keyword">with</span> -A<span class="hljs-keyword">Database</span> <span class="hljs-keyword">changed</span>MySQL [<span class="hljs-keyword">test</span>]&gt; <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> test1 (    <span class="hljs-keyword">id</span> <span class="hljs-built_in">INT</span> PRIMARY <span class="hljs-keyword">KEY</span> AUTO_INCREMENT,    <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,    sex <span class="hljs-built_in">varchar</span>(<span class="hljs-number">1024</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=latin1;    <span class="hljs-comment"># 创建测试用的test1表</span></code></pre><h3 id="3-3-往表中写入和读取中文数据"><a href="#3-3-往表中写入和读取中文数据" class="headerlink" title="3.3 往表中写入和读取中文数据"></a>3.3 往表中写入和读取中文数据</h3><p>​    下面我们将演示，如何往latin表中写入和读取utf-8编码的中文数据</p><h4 id="3-3-1-创建测试脚本"><a href="#3-3-1-创建测试脚本" class="headerlink" title="3.3.1 创建测试脚本"></a>3.3.1 创建测试脚本</h4><p>​    在你的家目录下，我们来新建一个测试用的python脚本，文件名为test.py</p><pre><code class="hljs vim">$ touch test.<span class="hljs-keyword">py</span>$ <span class="hljs-keyword">vim</span> test.<span class="hljs-keyword">py</span></code></pre><p>​    我们将以下的文本内容，拷贝至test.py文件里：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment"># -*- coding: gbk -*-     #在Python文件的开头指定编码，值为gbk或者utf-8</span><span class="hljs-keyword">import</span> MySQLdb<span class="hljs-comment"># 作者为了方便，对原有的MySQLdb数据库类的一些db操作进行的一个简单的封装成DataBase这个类，大家也可以直接使用MySQLdb</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataBase</span>(<span class="hljs-params">object</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, host=<span class="hljs-string">&quot;127.0.0.1&quot;</span>, user=<span class="hljs-string">&quot;root&quot;</span>, passwd=<span class="hljs-string">&quot;123456&quot;</span>, db=<span class="hljs-string">&quot;test&quot;</span>, charset=<span class="hljs-string">&quot;latin1&quot;</span></span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> passwd:            self.db = MySQLdb.connect(host=host, user=user,                                      db=db, charset=charset)        <span class="hljs-keyword">else</span>:            self.db = MySQLdb.connect(host=host, user=user, passwd=passwd,                                      db=db, charset=charset)        self.cursor = self.db.cursor()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, sql</span>):</span>        <span class="hljs-keyword">try</span>:            self.cursor.execute(sql)            self.db.commit()            results = self.cursor.fetchall()            <span class="hljs-keyword">return</span> results        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(str(e))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">executemany</span>(<span class="hljs-params">self, sql, param_list</span>):</span>        <span class="hljs-keyword">try</span>:            self.cursor.executemany(sql, param_list)            self.db.commit()        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:            print(str(e))db = DataBase()<span class="hljs-comment"># 1. 写入数据</span>student_name = <span class="hljs-string">u&#x27;小强&#x27;</span>    <span class="hljs-comment"># 该中文数据此时为unicode类型</span>sql = <span class="hljs-string">&quot;insert into test1 values (1, &#x27;%s&#x27;, &#x27;male&#x27;)&quot;</span> %(student_name.encode(<span class="hljs-string">&#x27;utf8&#x27;</span>)) <span class="hljs-comment"># 我们将unicode数据根据自己需要，转换成对应编码，比如这里我转换成utf8编码</span>db.execute(sql)<span class="hljs-comment"># 2. 获取数据</span>sql = <span class="hljs-string">&quot;select name from test1&quot;</span>results = db.execute(sql)<span class="hljs-keyword">for</span> result <span class="hljs-keyword">in</span> results:    print(type(result[<span class="hljs-number">0</span>]))    print(result[<span class="hljs-number">0</span>].encode(<span class="hljs-string">&#x27;latin1&#x27;</span>).decode(<span class="hljs-string">&#x27;utf8&#x27;</span>)) <span class="hljs-comment"># 此时中文数据为unicode，转换成unicode则不会因为中文数据编码和脚本编码不一致而导致打印出现异常</span></code></pre><h4 id="3-3-2-执行脚本"><a href="#3-3-2-执行脚本" class="headerlink" title="3.3.2 执行脚本"></a>3.3.2 执行脚本</h4><pre><code class="hljs vim">$ <span class="hljs-keyword">python</span> test.<span class="hljs-keyword">py</span></code></pre><p>​    脚本的执行结果如下：</p><pre><code class="hljs ada">&lt;<span class="hljs-keyword">type</span> <span class="hljs-type">&#x27;unicode&#x27;&gt;</span><span class="hljs-type">小强</span></code></pre><h2 id="4-优化建议"><a href="#4-优化建议" class="headerlink" title="4. 优化建议"></a>4. 优化建议</h2><p>​        如果你需要在DB中存储中文数据，那我个人建议在建表的时候指定utf8编码，这样我们可以非常明确表中存储的中文数据就一定是utf8编码的。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ol><li><a href="http://cenalulu.github.io/mysql/mysql-mojibake/">10分钟学会理解和解决MySQL乱码问题</a>(非常优秀的一篇文章)</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/13/hello-world/"/>
    <url>/2020/08/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
